<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <title>Color Mixer</title>
  <style>
    :root {
      --cell-size: 60px; /* auto-updated by resizeBoard() */
      --gap: 5px;
      --debris-size: 6px;
    }

    body {
      font-family: sans-serif;
      background: #000;
      color: #fff;
      margin: 0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    /* SCORE */
    #score {
      font-size: 72px; font-weight: 900; letter-spacing: 1px;
      margin: 12px 0 8px; text-align: center;
    }

    /* HUD */
    #topbar {
      display: flex; align-items: center; justify-content: center;
      gap: 28px; margin: 2px 0 16px;
    }
    #thermo { height: 72px; image-rendering: -webkit-optimize-contrast; }
    #ice    { height: 80px; image-rendering: -webkit-optimize-contrast; }
    #clearedProgress { font-size: 32px; min-width: 110px; text-align: right; }

    /* BOARD */
    #grid {
      position: relative; /* debris are absolutely positioned inside */
      width: calc(var(--cell-size) * 8 + var(--gap) * 7);
      height: calc(var(--cell-size) * 8 + var(--gap) * 7);
      background: #000;
      touch-action: manipulation; /* better mobile taps */
      -webkit-tap-highlight-color: transparent;
      overflow: hidden; /* keep debris inside */
    }

    .cell {
      width: var(--cell-size); height: var(--cell-size);
      border-radius: 12px; position: absolute;
      transition: transform 300ms ease-out;
      display: flex; align-items: center; justify-content: center;
      font-weight: bold; font-size: 25px; color: white;
      text-shadow: 1px 1px 0 black, -1px 1px 0 black, 1px -1px 0 black, -1px -1px 0 black;
      background-size: cover; background-repeat: no-repeat; background-position: center;
      will-change: transform;
      z-index: 1;
    }
    .highlight { outline: 3px solid white; box-shadow: 0 0 8px white; z-index: 2; }

    /* Pre-fade on the tiles themselves */
    .shatter { animation: fadeShatter 450ms ease-out forwards; }
    @keyframes fadeShatter { to { opacity: 0; filter: blur(3px) brightness(1.3); } }

    /* Debris pieces */
    .debris {
      position: absolute; width: var(--debris-size); height: var(--debris-size);
      border-radius: 2px; pointer-events: none;
      background-image: url('brown.png'); background-size: cover; background-position: center;
      background-color: #654321; /* fallback tint */
      opacity: 1;
      transform: translate3d(0,0,0);
      transition: transform 520ms ease-out, opacity 520ms ease-out, filter 520ms ease-out;
      filter: drop-shadow(0 0 2px rgba(0,0,0,.7));
      will-change: transform, opacity, filter;
      z-index: 5; /* above cells */
    }

    /* Hidden legacy readouts */
    #heat, #cleared { display: none; }

    /* Mobile tweaks */
    @media (max-width: 900px) {
      :root { --gap: 4px; --debris-size: 8px; }
    }
  </style>
</head>
<body>
  <div id="score">0</div>

  <div id="topbar">
    <img id="thermo" alt="Heat" src="heat0.png"/>
    <div id="clearedProgress">0/50</div>
    <img id="ice" alt="Ice" src="ice.png"/>
  </div>

  <!-- kept for logic; visually replaced by HUD -->
  <div id="heat">Heat: 0</div>
  <div id="cleared">Blocks Cleared: 0</div>

  <div id="grid"></div>

  <script>
    const gridSize = 8;

    // ===== Constants (no tuning UI) =====
    const MULT_BROWN = 100;
    const MULT_SECONDARY = 10;
    const HEAT_LIMIT = 4;
    const BROWN_FLASH_MS = 250;
    const BLOCK_CLEAR_LIMIT = 50;
    const BROWN_THRESHOLD = 2000;      // big-brown instant cool (effectively unused unless huge groups)
    const BROWN_STREAK_LIMIT = 3000;   // effectively disabled unless you want streak logic later

    // Image files
    const IMAGES = {
      R: 'red.png',
      B: 'blue.png',
      Y: 'yellow.png',
      P: 'purple.png',
      G: 'green.png',
      O: 'orange.png',
      brown: 'brown.png'
    };
    const UI_IMAGES = ['heat0.png','heat1.png','heat2.png','heat3.png','heat4.png','ice.png'];

    const PRIMARIES = ['R', 'B', 'Y'];
    const SECONDARIES = ['P', 'G', 'O'];

    let board = [];
    let cells = [];
    let selected = null;
    let score = 0;
    let heat = 0;
    let brownStreak = 0;
    let clearedBlocks = 0;
    let inputLocked = false;
    let gameOverScheduled = false;

    const grid = document.getElementById('grid');
    const scoreEl = document.getElementById('score');
    const heatEl = document.getElementById('heat');
    const thermoEl = document.getElementById('thermo');
    const clearedEl = document.getElementById('cleared');
    const clearedProgressEl = document.getElementById('clearedProgress');

    /* Helpers to read current CSS sizes (responsive) */
    function sizes() {
      const rs = getComputedStyle(document.documentElement);
      return {
        cell: parseInt(rs.getPropertyValue('--cell-size')) || 60,
        gap: parseInt(rs.getPropertyValue('--gap')) || 5
      };
    }
    function getPosition(r, c) {
      const { cell, gap } = sizes();
      return { top: r * (cell + gap), left: c * (cell + gap) };
    }

    function randomPrimary() { return PRIMARIES[Math.floor(Math.random() * PRIMARIES.length)]; }

    function mixColors(a, b) {
      const pair = new Set([a, b]);
      if (pair.has('R') && pair.has('B')) return 'P';
      if (pair.has('B') && pair.has('Y')) return 'G';
      if (pair.has('R') && pair.has('Y')) return 'O';
      if (pair.has('P') && pair.has('Y')) return 'brown';
      if (pair.has('G') && pair.has('R')) return 'brown';
      if (pair.has('O') && pair.has('B')) return 'brown';
      return null;
    }

    function setCellImage(div, key) {
      div.style.backgroundImage = `url(${IMAGES[key] || IMAGES.brown})`;
    }

    function formatScore(n) { return n.toLocaleString(); }

    function updateScore(amount) {
      score += amount;
      scoreEl.textContent = formatScore(score);
    }

    // Heat → heat0..heat4.png
    function updateThermometer() {
      const ratio = Math.max(0, Math.min(1, heat / Math.max(1, HEAT_LIMIT)));
      const level = Math.min(4, Math.floor(ratio * 4 + 0.0001)); // 0..4
      thermoEl.src = `heat${level}.png`;
    }

    function maybeScheduleGameOver() {
      if (!gameOverScheduled && heat >= HEAT_LIMIT) {
        gameOverScheduled = true;
        // brief delay so last score visibly updates
        setTimeout(() => { alert('Game Over — Heat Limit Reached!'); initialize(); }, 650);
      }
    }

    function addHeat(delta) {
      heat += delta;
      heatEl.textContent = `Heat: ${heat}`;
      updateThermometer();
      maybeScheduleGameOver();
    }

    function updateClearedDisplay() {
      clearedEl.textContent = `Blocks Cleared: ${clearedBlocks}`;
      clearedProgressEl.textContent = `${Math.min(clearedBlocks, BLOCK_CLEAR_LIMIT)}/${BLOCK_CLEAR_LIMIT}`;
    }

    function clearHighlights() {
      for (let r = 0; r < gridSize; r++) {
        for (let c = 0; c < gridSize; c++) {
          const cell = cells[r][c];
          if (cell) { cell.classList.remove('highlight'); cell.textContent = ''; }
        }
      }
    }

    function createCell(r, c, color) {
      const div = document.createElement('div');
      div.className = 'cell';
      setCellImage(div, color);
      const { top, left } = getPosition(r, c);
      div.style.transform = `translate(${left}px, ${top}px)`;
      div.dataset.r = r; div.dataset.c = c; div.dataset.color = color;
      grid.appendChild(div);
      return div;
    }

    function flood(r, c, color) {
      const result = [];
      const visited = Array.from({ length: gridSize }, () => Array(gridSize).fill(false));
      const stack = [[r, c]];
      while (stack.length) {
        const [cr, cc] = stack.pop();
        if (cr < 0 || cc < 0 || cr >= gridSize || cc >= gridSize) continue;
        if (visited[cr][cc] || board[cr][cc] !== color) continue;
        visited[cr][cc] = true;
        result.push([cr, cc]);
        stack.push([cr - 1, cc], [cr + 1, cc], [cr, cc - 1], [cr, cc + 1]);
      }
      return result;
    }

    function animateFall() {
      for (let c = 0; c < gridSize; c++) {
        let stack = [];
        for (let r = gridSize - 1; r >= 0; r--) {
          if (board[r][c] !== null) stack.push([board[r][c], cells[r][c]]);
        }
        for (let r = gridSize - 1; r >= 0; r--) {
          let entry = stack.shift();
          if (entry) {
            const [color, cell] = entry;
            board[r][c] = color;
            cells[r][c] = cell;
            const { top, left } = getPosition(r, c);
            cell.dataset.r = r; cell.dataset.c = c;
            cell.style.transform = `translate(${left}px, ${top}px)`;
          } else {
            const color = randomPrimary();
            board[r][c] = color;
            const cell = createCell(-1, c, color);
            cells[r][c] = cell;
            cell.dataset.r = r; cell.dataset.c = c;
            const { top, left } = getPosition(r, c);
            setTimeout(() => {
              cell.style.transform = `translate(${left}px, ${top}px)`;
              cell.dataset.r = r; cell.dataset.c = c;
            }, 50);
          }
        }
      }
    }

    // Tiny debris spawner for a list of [r,c] cells
    function spawnDebris(cellsList) {
      const piecesPerCell = 10;
      const life = 600; // ms (a bit longer for mobile visibility)
      const created = [];
      const { cell } = sizes();

      for (const [rr, cc] of cellsList) {
        const { left, top } = getPosition(rr, cc);
        for (let i = 0; i < piecesPerCell; i++) {
          const d = document.createElement('div');
          d.className = 'debris';
          const size = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--debris-size'));
          d.style.left = (left + Math.random() * (cell - size)) + 'px';
          d.style.top  = (top  + Math.random() * (cell - size)) + 'px';
          grid.appendChild(d);
          created.push(d);

          const dx = (Math.random() * 2 - 1) * 44;
          const dy = (Math.random() * 2 - 1) * 44;

          // Force layout before transition (helps some mobile webviews)
          // eslint-disable-next-line no-unused-expressions
          d.offsetWidth;

          requestAnimationFrame(() => {
            d.style.transform = `translate3d(${dx}px, ${dy}px, 0) rotate(${(Math.random()*120-60)}deg)`;
            d.style.opacity = '0';
            d.style.filter = 'blur(1px)';
          });
        }
      }
      setTimeout(() => created.forEach(p => p.remove()), life + 40);
    }

    function initialize() {
      board = []; cells = []; selected = null;
      score = 0; heat = 0; brownStreak = 0; clearedBlocks = 0;
      inputLocked = false; gameOverScheduled = false;
      grid.innerHTML = '';
      scoreEl.textContent = '0';
      updateThermometer();
      updateClearedDisplay();

      for (let r = 0; r < gridSize; r++) {
        const row = [], cellRow = [];
        for (let c = 0; c < gridSize; c++) {
          const color = randomPrimary();
          row.push(color);
          const cell = createCell(r, c, color);
          cellRow.push(cell);
        }
        board.push(row); cells.push(cellRow);
      }
    }

    // ===== Responsive board sizing =====
    function resizeBoard() {
      const padding = 32; // approximate outer padding
      const vw = window.innerWidth || 360;
      const target = Math.max(280, Math.min(vw - padding * 2, 720)); // clamp width
      const gap = sizes().gap;
      const cell = Math.floor((target - gap * 7) / 8);
      document.documentElement.style.setProperty('--cell-size', cell + 'px');

      // scale HUD a bit with cell size
      const thermo = document.getElementById('thermo');
      const ice = document.getElementById('ice');
      if (thermo && ice) {
        thermo.style.height = Math.round(cell * 1.2) + 'px';
        ice.style.height = Math.round(cell * 1.3) + 'px';
      }
    }
    window.addEventListener('resize', resizeBoard, { passive: true });
    window.addEventListener('orientationchange', resizeBoard);

    // ===== Nearest-tile tap targeting + debounce via Pointer Events =====
    let lastPointerTime = 0;
    let downPos = null;
    const DEBOUNCE_MS = 220;
    const TAP_MOVE_TOL = 10; // px

    function nearestCellFromPoint(clientX, clientY) {
      const rect = grid.getBoundingClientRect();
      const x = clientX - rect.left;
      const y = clientY - rect.top;
      const { cell, gap } = sizes();
      let c = Math.round((x - cell / 2) / (cell + gap));
      let r = Math.round((y - cell / 2) / (cell + gap));
      c = Math.max(0, Math.min(gridSize - 1, c));
      r = Math.max(0, Math.min(gridSize - 1, r));
      return [r, c];
    }

    grid.addEventListener('pointerdown', (e) => {
      if (e.button !== 0) return; // only primary
      downPos = { x: e.clientX, y: e.clientY };
    }, { passive: true });

    grid.addEventListener('pointerup', (e) => {
      const now = performance.now();
      if (now - lastPointerTime < DEBOUNCE_MS) return; // debounce

      const moved = downPos ? Math.hypot(e.clientX - downPos.x, e.clientY - downPos.y) : 0;
      downPos = null;
      if (moved > TAP_MOVE_TOL) return; // ignore drags

      lastPointerTime = now;

      const [r, c] = nearestCellFromPoint(e.clientX, e.clientY);
      e.preventDefault();
      handleClick(r, c);
    }, { passive: false });

    // Block legacy synthesized clicks on some webviews
    grid.addEventListener('click', (e) => e.preventDefault(), { passive: false });

    // Main game click logic
    function handleClick(r, c) {
      if (inputLocked || gameOverScheduled) return;
      clearHighlights();

      if (!selected) {
        selected = [r, c];
        const color = board[r][c];
        const group = flood(r, c, color);
        group.forEach(([gr, gc]) => {
          const cellEl = cells[gr][gc];
          if (cellEl) { cellEl.classList.add('highlight'); cellEl.textContent = group.length; }
        });
        return;
      }

      const [sr, sc] = selected;
      selected = null;

      const color1 = board[sr][sc];
      const color2 = board[r][c];
      const mix = mixColors(color1, color2);

      if (mix === 'brown') {
        const group1 = flood(sr, sc, color1);
        const group2 = flood(r, c, color2);
        const g1 = group1.length, g2 = group2.length;
        const total = g1 + g2;

        const scoreAmount = g1 * g2 * MULT_BROWN;
        updateScore(scoreAmount);

        clearedBlocks += total;
        updateClearedDisplay();

        const cellsToRemove = [];
        for (const [rr, cc] of group1.concat(group2)) {
          const cellEl = cells[rr][cc];
          if (!cellEl) continue;
          cellEl.classList.remove('highlight'); cellEl.textContent = '';
          setCellImage(cellEl, 'brown');
          board[rr][cc] = null; // mark empty for fall later
          cellsToRemove.push([rr, cc]);
        }

        inputLocked = true;

        // After the adjustable flash, explode into debris + shatter
        setTimeout(() => {
          for (const [rr, cc] of cellsToRemove) {
            const cellEl = cells[rr][cc];
            if (cellEl) cellEl.classList.add('shatter');
          }
          spawnDebris(cellsToRemove);
        }, BROWN_FLASH_MS);

        // Remove cells after flash + debris life
        setTimeout(() => {
          for (const [rr, cc] of cellsToRemove) {
            const cellEl = cells[rr][cc];
            if (cellEl && cellEl.parentNode === grid) cellEl.remove();
            cells[rr][cc] = null;
          }

          // Resets tied to brown (kept for parity with earlier logic)
          if (g1 + g2 >= BROWN_THRESHOLD || ++brownStreak >= BROWN_STREAK_LIMIT) {
            heat = 0; brownStreak = 0; updateThermometer();
          }

          // Block-clear reset (50) – cools heat
          if (clearedBlocks >= BLOCK_CLEAR_LIMIT) {
            heat = 0; clearedBlocks = 0; updateClearedDisplay(); updateThermometer();
          }

          animateFall();
          inputLocked = false;
        }, BROWN_FLASH_MS + 620); // debris anim ~600ms

      } else if (!SECONDARIES.includes(color1) && !SECONDARIES.includes(color2) && mix) {
        // Primary + Primary → Secondary (score FIRST, then heat)
        const group1 = flood(sr, sc, color1);
        const group2 = flood(r, c, color2);
        const g1 = group1.length, g2 = group2.length;

        const scoreAmount = g1 * g2 * MULT_SECONDARY;
        updateScore(scoreAmount);

        for (const [rr, cc] of group1.concat(group2)) {
          board[rr][cc] = mix;
          const cellEl = cells[rr][cc];
          setCellImage(cellEl, mix);
          cellEl.dataset.color = mix;
        }

        brownStreak = 0;
        addHeat(1); // last-move score already shown

      } else {
        // No scoring change, but if it was a valid non-brown mix attempt, add heat
        if (color1 !== color2 && mix !== 'brown' && mix !== null) {
          brownStreak = 0;
          addHeat(1);
        }
      }
    }

    // ===== Boot sequence =====
    function preloadImages() {
      const sources = [...Object.values(IMAGES), ...UI_IMAGES];
      return Promise.all(sources.map(src => new Promise(res => {
        const img = new Image(); img.onload = res; img.onerror = res; img.src = src;
      })));
    }

    function resizeBoard() {
      const padding = 32;
      const vw = window.innerWidth || 360;
      const target = Math.max(280, Math.min(vw - padding * 2, 720));
      const gap = sizes().gap;
      const cell = Math.floor((target - gap * 7) / 8);
      document.documentElement.style.setProperty('--cell-size', cell + 'px');

      // scale HUD with cell size
      const thermo = document.getElementById('thermo');
      const ice = document.getElementById('ice');
      if (thermo && ice) {
        thermo.style.height = Math.round(cell * 1.2) + 'px';
        ice.style.height = Math.round(cell * 1.3) + 'px';
      }
    }

    preloadImages().then(() => {
      resizeBoard(); // compute size before laying out cells
      initialize();
    });

    window.addEventListener('resize', resizeBoard, { passive: true });
    window.addEventListener('orientationchange', resizeBoard);
  </script>
</body>
</html>
