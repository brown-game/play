<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <title>Color Mixer</title>
  <style>
    :root {
      --cell-size: 60px;     /* auto-updated by resizeBoard() */
      --gap: 5px;
      --board-w: calc(var(--cell-size) * 8 + var(--gap) * 7);
    }

    body {
      font-family: sans-serif;
      background: #000;
      color: #fff;
      margin: 0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding-left: env(safe-area-inset-left);
      padding-right: env(safe-area-inset-right);
      padding-top: env(safe-area-inset-top);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    /* BEST (top-left, crown image + number) */
    #best {
      position: fixed;
      top: calc(8px + env(safe-area-inset-top));
      left: calc(10px + env(safe-area-inset-left));
      display: flex;
      align-items: center;
      gap: 6px;
      z-index: 50;
      user-select: none;
      pointer-events: none;
      -webkit-text-stroke: 1px #000;
      text-shadow:
        1px 1px 0 #000, -1px 1px 0 #000,
        1px -1px 0 #000, -1px -1px 0 #000;
    }
    #best img { height: 28px; width: auto; display: block; }
    #best span {
      font-size: 22px; font-weight: 800; letter-spacing: .5px;
      opacity: .92;
    }

    /* SCORE (center top) — margin-top is set dynamically to clear the BEST bar */
    #score {
      font-size: 72px; font-weight: 900; letter-spacing: 1px;
      margin: 12px 0 8px; text-align: center;
      position: relative;
      transition: margin-top 150ms ease-out;
    }

    /* HUD (thermometer, 0/50, ice) */
    #topbar {
      display: flex; align-items: center; justify-content: space-between;
      width: var(--board-w);
      padding-left: calc(12px + env(safe-area-inset-left));
      padding-right: calc(12px + env(safe-area-inset-right));
      box-sizing: border-box;
      margin: 2px 0 16px;
      gap: 16px;
    }
    #thermo, #ice { image-rendering: -webkit-optimize-contrast; display: block; }
    #clearedProgress { font-size: 32px; text-align: center; flex: 0 0 auto; }

    /* BOARD */
    #grid {
      position: relative;
      width: var(--board-w);
      height: calc(var(--cell-size) * 8 + var(--gap) * 7);
      background: #000;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      overflow: hidden;
    }

    .cell {
      width: var(--cell-size); height: var(--cell-size);
      border-radius: 12px; position: absolute;
      transition: transform 300ms ease-out;
      display: flex; align-items: center; justify-content: center;
      font-weight: bold; font-size: 25px; color: white;
      text-shadow: 1px 1px 0 black, -1px 1px 0 black, 1px -1px 0 black, -1px -1px 0 black;
      background-size: cover; background-repeat: no-repeat; background-position: center;
      will-change: transform;
      z-index: 1;
    }
    .highlight { outline: 3px solid white; box-shadow: 0 0 8px white; z-index: 2; }

    /* Pure fade-out for removals */
    .fadeOut { animation: fadeOut 400ms ease-out forwards; }
    @keyframes fadeOut { to { opacity: 0; } }

    /* Floating +points text */
    .float-points {
      position: fixed; left: 0; top: 0;
      font-weight: 900;
      font-size: 36px; /* ~half of score (72px) */
      color: #fff;
      pointer-events: none;
      z-index: 20;
      -webkit-text-stroke: 2px #000;
      text-shadow:
        1px 1px 0 #000, -1px 1px 0 #000,
        1px -1px 0 #000, -1px -1px 0 #000,
        2px 0 0 #000, -2px 0 0 #000,
        0 2px 0 #000, 0 -2px 0 #000;
      transform: translate(-50%, -50%);
    }

    /* Hidden legacy readouts */
    #heat, #cleared { display: none; }

    @media (max-width: 900px) {
      :root { --gap: 4px; }
    }
  </style>
</head>
<body>
  <!-- Top-left BEST -->
  <div id="best">
    <img src="crown.webp" alt="High Score"/>
    <span id="bestScoreText">0</span>
  </div>

  <!-- Center score -->
  <div id="score">0</div>

  <div id="topbar">
    <img id="thermo" alt="Heat" src="heat0.webp"/>
    <div id="clearedProgress">0/50</div>
    <img id="ice" alt="Ice" src="ice.webp"/>
  </div>

  <!-- kept for logic; visually replaced by HUD -->
  <div id="heat">Heat: 0</div>
  <div id="cleared">Blocks Cleared: 0</div>

  <div id="grid"></div>

  <script>
    const gridSize = 8;

    // ===== Defaults =====
    const MULT_BROWN = 100;
    const MULT_SECONDARY = 10;
    const HEAT_LIMIT = 4;
    const BROWN_FLASH_MS = 250;
    const BLOCK_CLEAR_LIMIT = 50;
    const BROWN_THRESHOLD = 2000;
    const BROWN_STREAK_LIMIT = 3000;

    // 90×90 WEBP tiles
    const IMAGES = {
      R: 'red.webp',
      B: 'blue.webp',
      Y: 'yellow.webp',
      P: 'purple.webp',
      G: 'green.webp',
      O: 'orange.webp',
      brown: 'brown.webp'
    };
    // Thermometer & ice are webp
    const UI_IMAGES = ['heat0.webp','heat1.webp','heat2.webp','heat3.webp','heat4.webp','ice.webp','crown.webp'];

    const PRIMARIES = ['R', 'B', 'Y'];
    const SECONDARIES = ['P', 'G', 'O'];

    let board = [];
    let cells = [];
    let selected = null;
    let score = 0;
    let heat = 0;
    let brownStreak = 0;
    let clearedBlocks = 0;

    let inputLocked = false;
    let gameOverScheduled = false;
    let pointsAnimRunning = false;
    let pendingGameOverAfterPoints = false;

    // High score
    let highScore = 0;
    const HIGH_KEY = 'highScoreV1';
    const bestEl = document.getElementById('best');
    const bestScoreText = document.getElementById('bestScoreText');

    // Cross-platform storage (Capacitor Preferences if available, else localStorage)
    const Storage = {
      async get(key) {
        try {
          const Cap = window.Capacitor;
          const Pref = window.Preferences || Cap?.Plugins?.Preferences || Cap?.Plugins?.Storage;
          if (Cap?.isNativePlatform?.() && Pref?.get) {
            const { value } = await Pref.get({ key });
            return value ?? null;
          }
        } catch (_) {}
        try { return localStorage.getItem(key); } catch { return null; }
      },
      async set(key, value) {
        try {
          const Cap = window.Capacitor;
          const Pref = window.Preferences || Cap?.Plugins?.Preferences || Cap?.Plugins?.Storage;
          if (Cap?.isNativePlatform?.() && Pref?.set) {
            await Pref.set({ key, value: String(value) });
            return;
          }
        } catch (_) {}
        try { localStorage.setItem(key, String(value)); } catch {}
      }
    };

    function updateBestUI() {
      bestScoreText.textContent = highScore.toLocaleString();
      // ensure the big score clears the BEST display visually
      requestAnimationFrame(offsetScoreUnderBest);
    }
    async function loadHighScore() {
      const raw = await Storage.get(HIGH_KEY);
      highScore = Math.max(0, parseInt(raw || '0', 10) || 0);
      updateBestUI();
    }
    async function maybeSaveHighScore() {
      if (score > highScore) {
        highScore = score;
        updateBestUI();
        await Storage.set(HIGH_KEY, String(highScore));
      }
    }

    const grid = document.getElementById('grid');
    const scoreEl = document.getElementById('score');
    const heatEl = document.getElementById('heat');
    const thermoEl = document.getElementById('thermo');
    const clearedEl = document.getElementById('cleared');
    const clearedProgressEl = document.getElementById('clearedProgress');

    /* Responsive sizes */
    function sizes() {
      const rs = getComputedStyle(document.documentElement);
      return {
        cell: parseInt(rs.getPropertyValue('--cell-size')) || 60,
        gap: parseInt(rs.getPropertyValue('--gap')) || 5
      };
    }
    function getPosition(r, c) {
      const { cell, gap } = sizes();
      return { top: r * (cell + gap), left: c * (cell + gap) };
    }

    function randomPrimary() { return PRIMARIES[Math.floor(Math.random() * PRIMARIES.length)]; }

    function mixColors(a, b) {
      const pair = new Set([a, b]);
      if (pair.has('R') && pair.has('B')) return 'P';
      if (pair.has('B') && pair.has('Y')) return 'G';
      if (pair.has('R') && pair.has('Y')) return 'O';
      if (pair.has('P') && pair.has('Y')) return 'brown';
      if (pair.has('G') && pair.has('R')) return 'brown';
      if (pair.has('O') && pair.has('B')) return 'brown';
      return null;
    }

    function setCellImage(div, key) {
      div.style.backgroundImage = `url(${IMAGES[key] || IMAGES.brown})`;
    }

    function formatScore(n) { return n.toLocaleString(); }
    function setScoreDisplay(n) { scoreEl.textContent = formatScore(n); }

    // Score increment animation (fast roll for 0.5s)
    function animateScoreIncrement(addAmount, duration = 500) {
      const startVal = score;
      const targetVal = score + addAmount;
      const start = performance.now();

      function step(now) {
        const t = Math.min(1, (now - start) / duration);
        const eased = 1 - Math.pow(1 - t, 3); // easeOutCubic
        const shown = Math.floor(startVal + addAmount * eased);
        setScoreDisplay(shown);
        if (t < 1) {
          requestAnimationFrame(step);
        } else {
          score = targetVal;             // finalize
          setScoreDisplay(score);
          maybeSaveHighScore();          // save BEST after score lands

          if (pendingGameOverAfterPoints) {
            pendingGameOverAfterPoints = false;
            setTimeout(() => { alert('Game Over — Heat Limit Reached!'); initialize(); }, 100);
          }
        }
      }
      requestAnimationFrame(step);
    }

    // Floating +points: hold 250ms at center, then arc to score
    function flyPointsToScore(addAmount, onHit) {
      pointsAnimRunning = true;

      const node = document.createElement('div');
      node.className = 'float-points';
      node.textContent = `+${addAmount}`;
      document.body.appendChild(node);

      const gridRect = grid.getBoundingClientRect();
      const scoreRect = scoreEl.getBoundingClientRect();

      const startX = gridRect.left + gridRect.width / 2;
      const startY = gridRect.top + gridRect.height / 2;

      const endX = scoreRect.left + scoreRect.width / 2;
      const endY = scoreRect.top + scoreRect.height / 2;

      const ctrlX = (startX + endX) / 2;
      const ctrlY = Math.min(startY, endY) - Math.max(60, gridRect.height * 0.2);

      const HOLD_MS = 250;
      const FLY_MS  = 700;

      node.style.transform = `translate(${startX}px, ${startY}px)`;

      function quadBezier(t, p0, p1, p2) {
        const u = 1 - t;
        return u*u*p0 + 2*u*t*p1 + t*t*p2;
      }

      setTimeout(() => {
        const startT = performance.now();
        function step(now) {
          const t = Math.min(1, (now - startT) / FLY_MS);
          const te = Math.sin((t * Math.PI) / 2); // easeOutSine
          const x = quadBezier(te, startX, ctrlX, endX);
          const y = quadBezier(te, startY, ctrlY, endY);
          node.style.transform = `translate(${x}px, ${y}px)`;
          node.style.opacity = String(0.6 + 0.4 * (1 - t));
          if (t < 1) requestAnimationFrame(step);
          else {
            node.remove();
            pointsAnimRunning = false;
            if (onHit) onHit();
          }
        }
        requestAnimationFrame(step);
      }, HOLD_MS);
    }

    // Thermometer (webp)
    function updateThermometer() {
      const ratio = Math.max(0, Math.min(1, heat / Math.max(1, HEAT_LIMIT)));
      const level = Math.min(4, Math.floor(ratio * 4 + 0.0001));
      thermoEl.src = `heat${level}.webp`;
    }

    function scheduleOrDeferGameOver() {
      if (pointsAnimRunning) {
        pendingGameOverAfterPoints = true;
      } else {
        setTimeout(() => { alert('Game Over — Heat Limit Reached!'); initialize(); }, 650);
      }
    }

    function maybeScheduleGameOver() {
      if (!gameOverScheduled && heat >= HEAT_LIMIT) {
        gameOverScheduled = true;
        scheduleOrDeferGameOver();
      }
    }

    function addHeat(delta) {
      heat += delta;
      heatEl.textContent = `Heat: ${heat}`;
      updateThermometer();
      maybeScheduleGameOver();
    }

    function updateClearedDisplay() {
      clearedEl.textContent = `Blocks Cleared: ${clearedBlocks}`;
      clearedProgressEl.textContent = `${Math.min(clearedBlocks, BLOCK_CLEAR_LIMIT)}/${BLOCK_CLEAR_LIMIT}`;
    }

    function clearHighlights() {
      for (let r = 0; r < gridSize; r++) {
        for (let c = 0; c < gridSize; c++) {
          const cell = cells[r][c];
          if (cell) { cell.classList.remove('highlight'); cell.textContent = ''; }
        }
      }
    }

    function createCell(r, c, color) {
      const div = document.createElement('div');
      div.className = 'cell';
      setCellImage(div, color);
      const { top, left } = getPosition(r, c);
      div.style.transform = `translate(${left}px, ${top}px)`;
      div.dataset.r = r; div.dataset.c = c; div.dataset.color = color;
      grid.appendChild(div);
      return div;
    }

    function flood(r, c, color) {
      const result = [];
      const visited = Array.from({ length: gridSize }, () => Array(gridSize).fill(false));
      const stack = [[r, c]];
      while (stack.length) {
        const [cr, cc] = stack.pop();
        if (cr < 0 || cc < 0 || cr >= gridSize || cc >= gridSize) continue;
        if (visited[cr][cc] || board[cr][cc] !== color) continue;
        visited[cr][cc] = true;
        result.push([cr, cc]);
        stack.push([cr - 1, cc], [cr + 1, cc], [cr, cc - 1], [cr, cc + 1]);
      }
      return result;
    }

    function animateFall() {
      for (let c = 0; c < gridSize; c++) {
        let stack = [];
        for (let r = gridSize - 1; r >= 0; r--) {
          if (board[r][c] !== null) stack.push([board[r][c], cells[r][c]]);
        }
        for (let r = gridSize - 1; r >= 0; r--) {
          let entry = stack.shift();
          if (entry) {
            const [color, cell] = entry;
            board[r][c] = color;
            cells[r][c] = cell;
            const { top, left } = getPosition(r, c);
            cell.dataset.r = r; cell.dataset.c = c;
            cell.style.transform = `translate(${left}px, ${top}px)`;
          } else {
            const color = randomPrimary();
            board[r][c] = color;
            const cell = createCell(-1, c, color);
            cells[r][c] = cell;
            cell.dataset.r = r; cell.dataset.c = c;
            const { top, left } = getPosition(r, c);
            setTimeout(() => {
              cell.style.transform = `translate(${left}px, ${top}px)`;
              cell.dataset.r = r; cell.dataset.c = c;
            }, 50);
          }
        }
      }
    }

    function initialize() {
      board = []; cells = []; selected = null;
      score = 0; heat = 0; brownStreak = 0; clearedBlocks = 0;
      inputLocked = false; gameOverScheduled = false;
      pointsAnimRunning = false; pendingGameOverAfterPoints = false;

      grid.innerHTML = '';
      setScoreDisplay(0);
      updateThermometer();
      updateClearedDisplay();

      for (let r = 0; r < gridSize; r++) {
        const row = [], cellRow = [];
        for (let c = 0; c < gridSize; c++) {
          const color = randomPrimary();
          row.push(color);
          const cell = createCell(r, c, color);
          cellRow.push(cell);
        }
        board.push(row); cells.push(cellRow);
      }
      // after initial layout, be sure score has room under BEST
      offsetScoreUnderBest();
    }

    // Make sure the large score clears the fixed BEST row on all devices
    function offsetScoreUnderBest() {
      const rect = bestEl.getBoundingClientRect();
      // add a little extra breathing room
      const offset = rect.height + 14; // px
      scoreEl.style.marginTop = offset + 'px';
    }

    // ===== Responsive board sizing =====
    function resizeBoard() {
      const padding = 32;
      const vw = window.innerWidth || 360;
      const target = Math.max(280, Math.min(vw - padding * 2, 720));
      const { gap } = sizes();
      const cell = Math.floor((target - gap * 7) / 8);
      document.documentElement.style.setProperty('--cell-size', cell + 'px');
      document.documentElement.style.setProperty('--board-w',
        `calc(${cell}px * 8 + ${gap}px * 7)`);

      const thermo = document.getElementById('thermo');
      const ice = document.getElementById('ice');
      if (thermo && ice) {
        thermo.style.height = Math.round(cell * 1.2) + 'px';
        ice.style.height = Math.round(cell * 1.3) + 'px';
      }

      // score offset may need recompute on resize/orientation
      offsetScoreUnderBest();
    }
    window.addEventListener('resize', resizeBoard, { passive: true });
    window.addEventListener('orientationchange', () => { resizeBoard(); offsetScoreUnderBest(); });

    // ===== Nearest-tile tap targeting + debounce (Pointer Events) =====
    let lastPointerTime = 0;
    let downPos = null;
    const DEBOUNCE_MS = 220;
    const TAP_MOVE_TOL = 10; // px

    function nearestCellFromPoint(clientX, clientY) {
      const rect = grid.getBoundingClientRect();
      const x = clientX - rect.left;
      const y = clientY - rect.top;
      const { cell, gap } = sizes();
      let c = Math.round((x - cell / 2) / (cell + gap));
      let r = Math.round((y - cell / 2) / (cell + gap));
      c = Math.max(0, Math.min(gridSize - 1, c));
      r = Math.max(0, Math.min(gridSize - 1, r));
      return [r, c];
    }

    grid.addEventListener('pointerdown', (e) => {
      if (e.button !== 0) return;
      downPos = { x: e.clientX, y: e.clientY };
    }, { passive: true });

    grid.addEventListener('pointerup', (e) => {
      const now = performance.now();
      if (now - lastPointerTime < DEBOUNCE_MS) return;

      const moved = downPos ? Math.hypot(e.clientX - downPos.x, e.clientY - downPos.y) : 0;
      downPos = null;
      if (moved > TAP_MOVE_TOL) return;

      lastPointerTime = now;

      const [r, c] = nearestCellFromPoint(e.clientX, e.clientY);
      e.preventDefault();
      handleClick(r, c);
    }, { passive: false });

    grid.addEventListener('click', (e) => e.preventDefault(), { passive: false });

    // ===== Main game click logic (with +points hold & arc) =====
    function handleClick(r, c) {
      if (inputLocked || gameOverScheduled) return;
      clearHighlights();

      if (!selected) {
        selected = [r, c];
        const color = board[r][c];
        const group = flood(r, c, color);
        group.forEach(([gr, gc]) => {
          const cellEl = cells[gr][gc];
          if (cellEl) { cellEl.classList.add('highlight'); cellEl.textContent = group.length; }
        });
        return;
      }

      const [sr, sc] = selected;
      selected = null;

      const color1 = board[sr][sc];
      const color2 = board[r][c];
      const mix = mixColors(color1, color2);

      if (mix === 'brown') {
        const group1 = flood(sr, sc, color1);
        const group2 = flood(r, c, color2);
        const g1 = group1.length, g2 = group2.length;
        const total = g1 + g2;

        const addAmount = g1 * g2 * MULT_BROWN;
        flyPointsToScore(addAmount, () => animateScoreIncrement(addAmount));

        clearedBlocks += total;
        updateClearedDisplay();

        const cellsToRemove = [];
        for (const [rr, cc] of group1.concat(group2)) {
          const cellEl = cells[rr][cc];
          if (!cellEl) continue;
          cellEl.classList.remove('highlight'); cellEl.textContent = '';
          setCellImage(cellEl, 'brown');
          board[rr][cc] = null;
          cellsToRemove.push([rr, cc]);
        }

        inputLocked = true;

        setTimeout(() => {
          for (const [rr, cc] of cellsToRemove) {
            const el = cells[rr][cc];
            if (el) el.classList.add('fadeOut');
          }
        }, BROWN_FLASH_MS);

        setTimeout(() => {
          for (const [rr, cc] of cellsToRemove) {
            const el = cells[rr][cc];
            if (el && el.parentNode === grid) el.remove();
            cells[rr][cc] = null;
          }

          if (g1 + g2 >= BROWN_THRESHOLD || ++brownStreak >= BROWN_STREAK_LIMIT) {
            heat = 0; brownStreak = 0; updateThermometer();
          }

          if (clearedBlocks >= BLOCK_CLEAR_LIMIT) {
            heat = 0; clearedBlocks = 0; updateClearedDisplay(); updateThermometer();
          }

          animateFall();
          inputLocked = false;
        }, BROWN_FLASH_MS + 420);

      } else if (!SECONDARIES.includes(color1) && !SECONDARIES.includes(color2) && mix) {
        const group1 = flood(sr, sc, color1);
        const group2 = flood(r, c, color2);
        const g1 = group1.length, g2 = group2.length;

        const addAmount = g1 * g2 * MULT_SECONDARY;
        flyPointsToScore(addAmount, () => animateScoreIncrement(addAmount));

        for (const [rr, cc] of group1.concat(group2)) {
          board[rr][cc] = mix;
          const cellEl = cells[rr][cc];
          setCellImage(cellEl, mix);
          cellEl.dataset.color = mix;
        }

        brownStreak = 0;
        addHeat(1);

      } else {
        if (color1 !== color2 && mix !== 'brown' && mix !== null) {
          brownStreak = 0;
          addHeat(1);
        }
      }
    }

    // ===== Boot sequence =====
    function preloadImages() {
      const sources = [...Object.values(IMAGES), ...UI_IMAGES];
      return Promise.all(sources.map(src => new Promise(res => {
        const img = new Image(); img.onload = res; img.onerror = res; img.src = src;
      })));
    }

    async function start() {
      resizeBoard();
      await loadHighScore();
      initialize();
    }

    preloadImages().then(start);
  </script>
</body>
</html>
